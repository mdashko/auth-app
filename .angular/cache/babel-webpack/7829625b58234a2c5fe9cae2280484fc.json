{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { NgZone, Pipe, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, EMPTY, isObservable, from } from 'rxjs';\nimport { distinctUntilChanged, switchMap, tap, catchError } from 'rxjs/operators';\n/**\n * class CdAware\n *\n * @description\n * This abstract class holds all the shared logic for the push pipe and the let directive\n * responsible for change detection\n * If you extend this class you need to implement how the update of the rendered value happens.\n * Also custom behaviour is something you need to implement in the extending class\n */\n\nfunction createCdAware(cfg) {\n  const potentialObservablesSubject = new Subject();\n  const observablesFromTemplate$ = potentialObservablesSubject.pipe(distinctUntilChanged());\n  const rendering$ = observablesFromTemplate$.pipe( // Compose the observables from the template and the strategy\n  switchMap(observable$ => {\n    // If the passed observable is:\n    // - undefined - No value set\n    // - null - null passed directly or no value set over `async` pipe\n    if (observable$ == null) {\n      // Update the value to render_creator with null/undefined\n      cfg.updateViewContextObserver.next(observable$); // Render the view\n\n      cfg.render(); // Stop further processing\n\n      return EMPTY;\n    }\n\n    const ob$ = isObservable(observable$) ? observable$ : from(observable$); // If a new Observable arrives, reset the value to render_creator\n    // We do this because we don't know when the next value arrives and want to get rid of the old value\n\n    cfg.resetContextObserver.next();\n    cfg.render();\n    return ob$.pipe(distinctUntilChanged(), tap(cfg.updateViewContextObserver), tap(() => cfg.render()), catchError(e => {\n      cfg.errorHandler.handleError(e);\n      return EMPTY;\n    }));\n  }));\n  return {\n    nextPotentialObservable(value) {\n      potentialObservablesSubject.next(value);\n    },\n\n    subscribe() {\n      return rendering$.subscribe();\n    }\n\n  };\n}\n/**\n * @description\n *\n * Determines if the application uses `NgZone` or `NgNoopZone` as ngZone service instance.\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { hasZone } from `utils/has-zone`;\n *\n * console.log(hasZone());\n * ```\n */\n\n\nfunction hasZone(z) {\n  return z instanceof NgZone;\n}\n\nfunction createRender(config) {\n  function render() {\n    if (hasZone(config.ngZone)) {\n      config.cdRef.markForCheck();\n    } else {\n      config.cdRef.detectChanges();\n    }\n  }\n\n  return render;\n}\n/**\n * @ngModule ReactiveComponentModule\n *\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * The current way of binding an observable to the view looks like that:\n *  ```html\n *  {{observable$ | async}}\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | async\"></component>\n * ```\n *\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render_creator all dirty marked\n *     components.\n *\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n *\n * `ngrxPush` pipe solves that problem.\n *\n * Included Features:\n *  - Take observables or promises, retrieve their values and render_creator the value to the template\n *  - Handling null and undefined values in a clean unified/structured way\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n *  - Distinct same values in a row to increase performance\n *  - Coalescing of change detection calls to boost performance\n *\n * @usageNotes\n *\n * `ngrxPush` pipe solves that problem. It can be used like shown here:\n * ```html\n * {{observable$ | ngrxPush}}\n * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | ngrxPush\"></component>\n * ```\n *\n * @publicApi\n */\n\n\nclass PushPipe {\n  constructor(cdRef, ngZone, errorHandler) {\n    this.resetContextObserver = {\n      next: () => this.renderedValue = undefined\n    };\n    this.updateViewContextObserver = {\n      next: value => this.renderedValue = value\n    };\n    this.cdAware = createCdAware({\n      render: createRender({\n        cdRef,\n        ngZone\n      }),\n      updateViewContextObserver: this.updateViewContextObserver,\n      resetContextObserver: this.resetContextObserver,\n      errorHandler\n    });\n    this.subscription = this.cdAware.subscribe({});\n  }\n\n  transform(potentialObservable) {\n    this.cdAware.nextPotentialObservable(potentialObservable);\n    return this.renderedValue;\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nPushPipe.ɵfac = function PushPipe_Factory(t) {\n  return new (t || PushPipe)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16), i0.ɵɵdirectiveInject(i0.NgZone, 16), i0.ɵɵdirectiveInject(i0.ErrorHandler, 16));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nPushPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"ngrxPush\",\n  type: PushPipe,\n  pure: false\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PushPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'ngrxPush',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ErrorHandler\n    }];\n  }, null);\n})();\n/**\n * @ngModule ReactiveComponentModule\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n * It also helps with several internal processing under the hood.\n *\n * The current way of binding an observable to the view looks like that:\n * ```html\n * <ng-container *ngIf=\"observableNumber$ | async as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * <app-number-special [number]=\"n\">\n * </app-number-special>\n * </ng-container>\n *  ```\n *\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n *\n * Included Features:\n * - binding is always present. (`*ngIf=\"truthy$ | async\"`)\n * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n * - a unified/structured way of handling null and undefined\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n * - distinct same values in a row (distinctUntilChanged operator)\n *\n * @usageNotes\n *\n * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n * `<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"observableNumber$; let n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n * ```\n *\n * In addition to that it provides us information from the whole observable context.\n * We can track the observables:\n * - next value\n * - error value\n * - complete state\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n * </app-number>\n * <ng-container *ngIf=\"e\">\n * There is an error: {{e}}\n * </ng-container>\n * <ng-container *ngIf=\"c\">\n * Observable completed: {{c}}\n * </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\n\n\nclass LetDirective {\n  constructor(cdRef, ngZone, templateRef, viewContainerRef, errorHandler) {\n    this.templateRef = templateRef;\n    this.viewContainerRef = viewContainerRef;\n    this.isEmbeddedViewCreated = false;\n    this.viewContext = {\n      $implicit: undefined,\n      ngrxLet: undefined,\n      $error: false,\n      $complete: false\n    };\n    this.resetContextObserver = {\n      next: () => {\n        // if not initialized no need to set undefined\n        if (this.isEmbeddedViewCreated) {\n          this.viewContext.$implicit = undefined;\n          this.viewContext.ngrxLet = undefined;\n          this.viewContext.$error = false;\n          this.viewContext.$complete = false;\n        }\n      }\n    };\n    this.updateViewContextObserver = {\n      next: value => {\n        this.viewContext.$implicit = value;\n        this.viewContext.ngrxLet = value; // to have init lazy\n\n        if (!this.isEmbeddedViewCreated) {\n          this.createEmbeddedView();\n        }\n      },\n      error: error => {\n        this.viewContext.$error = true; // to have init lazy\n\n        if (!this.isEmbeddedViewCreated) {\n          this.createEmbeddedView();\n        }\n      },\n      complete: () => {\n        this.viewContext.$complete = true; // to have init lazy\n\n        if (!this.isEmbeddedViewCreated) {\n          this.createEmbeddedView();\n        }\n      }\n    };\n    this.cdAware = createCdAware({\n      render: createRender({\n        cdRef,\n        ngZone\n      }),\n      resetContextObserver: this.resetContextObserver,\n      updateViewContextObserver: this.updateViewContextObserver,\n      errorHandler\n    });\n    this.subscription = this.cdAware.subscribe({});\n  }\n\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n\n  set ngrxLet(potentialObservable) {\n    this.cdAware.nextPotentialObservable(potentialObservable);\n  }\n\n  createEmbeddedView() {\n    this.isEmbeddedViewCreated = true;\n    this.viewContainerRef.createEmbeddedView(this.templateRef, this.viewContext);\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLetDirective.ɵfac = function LetDirective_Factory(t) {\n  return new (t || LetDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ErrorHandler));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LetDirective,\n  selectors: [[\"\", \"ngrxLet\", \"\"]],\n  inputs: {\n    ngrxLet: \"ngrxLet\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LetDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngrxLet]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.TemplateRef\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ErrorHandler\n    }];\n  }, {\n    ngrxLet: [{\n      type: Input\n    }]\n  });\n})();\n\nconst DECLARATIONS = [LetDirective, PushPipe];\nconst EXPORTS = [DECLARATIONS];\n\nclass ReactiveComponentModule {}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nReactiveComponentModule.ɵfac = function ReactiveComponentModule_Factory(t) {\n  return new (t || ReactiveComponentModule)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nReactiveComponentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ReactiveComponentModule\n});\n/** @nocollapse */\n\n/** @nocollapse */\n\nReactiveComponentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ReactiveComponentModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DECLARATIONS],\n      exports: [EXPORTS]\n    }]\n  }], null, null);\n})();\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LetDirective, PushPipe, ReactiveComponentModule };","map":{"version":3,"sources":["/Users/marta/auth-app/node_modules/@ngrx/component/fesm2015/ngrx-component.mjs"],"names":["i0","NgZone","Pipe","Directive","Input","NgModule","Subject","EMPTY","isObservable","from","distinctUntilChanged","switchMap","tap","catchError","createCdAware","cfg","potentialObservablesSubject","observablesFromTemplate$","pipe","rendering$","observable$","updateViewContextObserver","next","render","ob$","resetContextObserver","e","errorHandler","handleError","nextPotentialObservable","value","subscribe","hasZone","z","createRender","config","ngZone","cdRef","markForCheck","detectChanges","PushPipe","constructor","renderedValue","undefined","cdAware","subscription","transform","potentialObservable","ngOnDestroy","unsubscribe","ɵfac","ChangeDetectorRef","ErrorHandler","ɵpipe","type","args","name","pure","LetDirective","templateRef","viewContainerRef","isEmbeddedViewCreated","viewContext","$implicit","ngrxLet","$error","$complete","createEmbeddedView","error","complete","ngTemplateContextGuard","dir","ctx","TemplateRef","ViewContainerRef","ɵdir","selector","DECLARATIONS","EXPORTS","ReactiveComponentModule","ɵmod","ɵinj","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { NgZone, Pipe, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, EMPTY, isObservable, from } from 'rxjs';\nimport { distinctUntilChanged, switchMap, tap, catchError } from 'rxjs/operators';\n\n/**\n * class CdAware\n *\n * @description\n * This abstract class holds all the shared logic for the push pipe and the let directive\n * responsible for change detection\n * If you extend this class you need to implement how the update of the rendered value happens.\n * Also custom behaviour is something you need to implement in the extending class\n */\nfunction createCdAware(cfg) {\n    const potentialObservablesSubject = new Subject();\n    const observablesFromTemplate$ = potentialObservablesSubject.pipe(distinctUntilChanged());\n    const rendering$ = observablesFromTemplate$.pipe(\n    // Compose the observables from the template and the strategy\n    switchMap((observable$) => {\n        // If the passed observable is:\n        // - undefined - No value set\n        // - null - null passed directly or no value set over `async` pipe\n        if (observable$ == null) {\n            // Update the value to render_creator with null/undefined\n            cfg.updateViewContextObserver.next(observable$);\n            // Render the view\n            cfg.render();\n            // Stop further processing\n            return EMPTY;\n        }\n        const ob$ = isObservable(observable$)\n            ? observable$\n            : from(observable$);\n        // If a new Observable arrives, reset the value to render_creator\n        // We do this because we don't know when the next value arrives and want to get rid of the old value\n        cfg.resetContextObserver.next();\n        cfg.render();\n        return ob$.pipe(distinctUntilChanged(), tap(cfg.updateViewContextObserver), tap(() => cfg.render()), catchError((e) => {\n            cfg.errorHandler.handleError(e);\n            return EMPTY;\n        }));\n    }));\n    return {\n        nextPotentialObservable(value) {\n            potentialObservablesSubject.next(value);\n        },\n        subscribe() {\n            return rendering$.subscribe();\n        },\n    };\n}\n\n/**\n * @description\n *\n * Determines if the application uses `NgZone` or `NgNoopZone` as ngZone service instance.\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { hasZone } from `utils/has-zone`;\n *\n * console.log(hasZone());\n * ```\n */\nfunction hasZone(z) {\n    return z instanceof NgZone;\n}\n\nfunction createRender(config) {\n    function render() {\n        if (hasZone(config.ngZone)) {\n            config.cdRef.markForCheck();\n        }\n        else {\n            config.cdRef.detectChanges();\n        }\n    }\n    return render;\n}\n\n/**\n * @ngModule ReactiveComponentModule\n *\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * The current way of binding an observable to the view looks like that:\n *  ```html\n *  {{observable$ | async}}\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | async\"></component>\n * ```\n *\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render_creator all dirty marked\n *     components.\n *\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n *\n * `ngrxPush` pipe solves that problem.\n *\n * Included Features:\n *  - Take observables or promises, retrieve their values and render_creator the value to the template\n *  - Handling null and undefined values in a clean unified/structured way\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n *  - Distinct same values in a row to increase performance\n *  - Coalescing of change detection calls to boost performance\n *\n * @usageNotes\n *\n * `ngrxPush` pipe solves that problem. It can be used like shown here:\n * ```html\n * {{observable$ | ngrxPush}}\n * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | ngrxPush\"></component>\n * ```\n *\n * @publicApi\n */\nclass PushPipe {\n    constructor(cdRef, ngZone, errorHandler) {\n        this.resetContextObserver = {\n            next: () => (this.renderedValue = undefined),\n        };\n        this.updateViewContextObserver = {\n            next: (value) => (this.renderedValue = value),\n        };\n        this.cdAware = createCdAware({\n            render: createRender({ cdRef, ngZone }),\n            updateViewContextObserver: this.updateViewContextObserver,\n            resetContextObserver: this.resetContextObserver,\n            errorHandler,\n        });\n        this.subscription = this.cdAware.subscribe({});\n    }\n    transform(potentialObservable) {\n        this.cdAware.nextPotentialObservable(potentialObservable);\n        return this.renderedValue;\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n}\n/** @nocollapse */ /** @nocollapse */ PushPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: PushPipe, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i0.ErrorHandler }], target: i0.ɵɵFactoryTarget.Pipe });\n/** @nocollapse */ /** @nocollapse */ PushPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: PushPipe, name: \"ngrxPush\", pure: false });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: PushPipe, decorators: [{\n            type: Pipe,\n            args: [{ name: 'ngrxPush', pure: false }]\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i0.ErrorHandler }]; } });\n\n/**\n * @ngModule ReactiveComponentModule\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n * It also helps with several internal processing under the hood.\n *\n * The current way of binding an observable to the view looks like that:\n * ```html\n * <ng-container *ngIf=\"observableNumber$ | async as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * <app-number-special [number]=\"n\">\n * </app-number-special>\n * </ng-container>\n *  ```\n *\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n *\n * Included Features:\n * - binding is always present. (`*ngIf=\"truthy$ | async\"`)\n * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n * - a unified/structured way of handling null and undefined\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n * - distinct same values in a row (distinctUntilChanged operator)\n *\n * @usageNotes\n *\n * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n * `<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"observableNumber$; let n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n * ```\n *\n * In addition to that it provides us information from the whole observable context.\n * We can track the observables:\n * - next value\n * - error value\n * - complete state\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n * </app-number>\n * <ng-container *ngIf=\"e\">\n * There is an error: {{e}}\n * </ng-container>\n * <ng-container *ngIf=\"c\">\n * Observable completed: {{c}}\n * </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\nclass LetDirective {\n    constructor(cdRef, ngZone, templateRef, viewContainerRef, errorHandler) {\n        this.templateRef = templateRef;\n        this.viewContainerRef = viewContainerRef;\n        this.isEmbeddedViewCreated = false;\n        this.viewContext = {\n            $implicit: undefined,\n            ngrxLet: undefined,\n            $error: false,\n            $complete: false,\n        };\n        this.resetContextObserver = {\n            next: () => {\n                // if not initialized no need to set undefined\n                if (this.isEmbeddedViewCreated) {\n                    this.viewContext.$implicit = undefined;\n                    this.viewContext.ngrxLet = undefined;\n                    this.viewContext.$error = false;\n                    this.viewContext.$complete = false;\n                }\n            },\n        };\n        this.updateViewContextObserver = {\n            next: (value) => {\n                this.viewContext.$implicit = value;\n                this.viewContext.ngrxLet = value;\n                // to have init lazy\n                if (!this.isEmbeddedViewCreated) {\n                    this.createEmbeddedView();\n                }\n            },\n            error: (error) => {\n                this.viewContext.$error = true;\n                // to have init lazy\n                if (!this.isEmbeddedViewCreated) {\n                    this.createEmbeddedView();\n                }\n            },\n            complete: () => {\n                this.viewContext.$complete = true;\n                // to have init lazy\n                if (!this.isEmbeddedViewCreated) {\n                    this.createEmbeddedView();\n                }\n            },\n        };\n        this.cdAware = createCdAware({\n            render: createRender({ cdRef, ngZone }),\n            resetContextObserver: this.resetContextObserver,\n            updateViewContextObserver: this.updateViewContextObserver,\n            errorHandler,\n        });\n        this.subscription = this.cdAware.subscribe({});\n    }\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    set ngrxLet(potentialObservable) {\n        this.cdAware.nextPotentialObservable(potentialObservable);\n    }\n    createEmbeddedView() {\n        this.isEmbeddedViewCreated = true;\n        this.viewContainerRef.createEmbeddedView(this.templateRef, this.viewContext);\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n}\n/** @nocollapse */ /** @nocollapse */ LetDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: LetDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i0.ErrorHandler }], target: i0.ɵɵFactoryTarget.Directive });\n/** @nocollapse */ /** @nocollapse */ LetDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.0\", type: LetDirective, selector: \"[ngrxLet]\", inputs: { ngrxLet: \"ngrxLet\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: LetDirective, decorators: [{\n            type: Directive,\n            args: [{ selector: '[ngrxLet]' }]\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i0.ErrorHandler }]; }, propDecorators: { ngrxLet: [{\n                type: Input\n            }] } });\n\nconst DECLARATIONS = [LetDirective, PushPipe];\nconst EXPORTS = [DECLARATIONS];\nclass ReactiveComponentModule {\n}\n/** @nocollapse */ /** @nocollapse */ ReactiveComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ReactiveComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ /** @nocollapse */ ReactiveComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ReactiveComponentModule, declarations: [LetDirective, PushPipe], exports: [LetDirective, PushPipe] });\n/** @nocollapse */ /** @nocollapse */ ReactiveComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ReactiveComponentModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ReactiveComponentModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [DECLARATIONS],\n                    exports: [EXPORTS],\n                }]\n        }] });\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LetDirective, PushPipe, ReactiveComponentModule };\n"]},"metadata":{},"sourceType":"module"}